#!/usr/bin/php -q
<?php

class Quill
{
	const HEDGEHOG_VERSION = "1.0";
	const HEDGEHOG_URL = "http://data.southampton.ac.uk/";

	private $creation_time;
	private $hopper_path;
	private $triples_file;
	private $quill_path;
	private $extra_triples;
	private $dumpfiles;

	public $errors;
	public $config;
	
	public $hash_check_result;
	public $hash_checked;

	// Define a few file-related functions so we don't have to keep calling the shell.

	private function deltree($dir) // Delete a non-empty directory
	{
		if(is_dir($dir))
		{
			if ($handle = opendir($dir))
			{
				while (false !== ($entry = readdir($handle)))
				{
					if(!(is_dir($entry)))
					{
						unlink($dir . "/" . $entry);
					}
					else
					{
						if((!(strcmp($entry, ".."))) & (!(strcmp($entry, "."))))
						{
							$this->deltree($dir . "/" . $entry);
						}
					}
				}
				closedir($handle);
			}
		}
		rmdir($dir);
	}

	private function dupdir($src, $dst) // Duplicate a directory (non-recursive)
	{
		if(!(is_dir($dst)))
		{
			mkdir($dst, 0755, true);
		}
		if(is_dir($src))
		{
			if ($handle = opendir($src))
			{
				while (false !== ($entry = readdir($handle)))
				{
					if(!(is_dir($src . "/" . $entry)))
					{
						$file_perms = fileperms($src . "/" . $entry);
						copy($src . "/" . $entry, $dst . "/" . $entry);
						chmod($dst . "/" . $entry, $file_perms);
					}
				}
				closedir($handle);
			}
		}
	}
	
	private function ensureDirExists($path)
	{
		@mkdir($path, 0755, true);
		return(is_dir($path));
	}

	private function wget($url, $file)
	{

		if(function_exists("curl_init"))
		{
			$ch = curl_init();
			$timeout = 5;
			curl_setopt($ch, CURLOPT_URL, $url);
			curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
			curl_setopt($ch, CURLOPT_USERAGENT, "Hedgehog/" . self::HEDGEHOG_VERSION . " (" . self::HEDGEHOG_URL . ")");
			curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);
			$data = curl_exec($ch);
			$error = curl_errno($ch);
			$httpCode = (int) curl_getinfo($ch, CURLINFO_HTTP_CODE);
			if(($error == 0) & ($httpCode < 400))
			{
				$fp = fopen($file, "w");
				fwrite($fp, $data);
				fclose($fp);
			}
			curl_close($ch);
		}
		else
		{
			// Included for portability, some PHP installs aren't compiled with cURL
			if(@$data = file_get_contents($url))
			{
				$fp = fopen($file, "w");
				fwrite($fp, $data);
				fclose($fp);
			}
		}
	}

	// A function to handle external processes better than shell_exec.

	private function externalScript($command_line)
	{
		$descriptorspec = array(
			0 => array("pipe", "r"),  // stdin
			1 => array("pipe", "w"),  // stdout
			2 => array("pipe", "w"),  // stderr
		);

		$process = proc_open($command_line, $descriptorspec, $pipes);
		$stdout = stream_get_contents($pipes[1]);
		fclose($pipes[1]);
		$stderr = stream_get_contents($pipes[2]);
		fclose($pipes[2]);
		$ret = proc_close($process);

		$r = array();
		$r['code'] = $ret;
		$r['stdout'] = $stdout;
		$r['stderr'] = $stderr;

		return($r);
	}
	
	private function loadSettingsFile($dataset_cfg)
	{
		// Check to see if the config file is valid
		@$json_obj = json_decode(implode("", file($dataset_cfg)), true);
		if(!(is_array($json_obj))) {
			$json_obj = array();
		}
		if( json_last_error() == JSON_ERROR_DEPTH )
		{
			$this->errors[] =  'Maximum stack depth exceeded in JSON';
		}
		if( json_last_error() == JSON_ERROR_CTRL_CHAR )
		{
			$this->errors[] = 'Unexpected control character found in JSON';
		}
		if( json_last_error() == JSON_ERROR_SYNTAX )
		{
			$this->errors[] = 'Syntax error, malformed JSON';
		}
		if(count($this->errors) == 0)
		{
			// only look for errors inside the JSON if the JSON was parsed OK
			if(!(array_key_exists("properties", $json_obj)))
			{
				$this->errors[] = "Missing 'properties' section in publish.json";
			}
			if((!(array_key_exists("additional_triples", $json_obj))) & (!(array_key_exists("triples", $json_obj))))
			{
				$this->errors[] = "Missing 'additional_triples' section in publish.json";
			}
			if(!(array_key_exists("downloads", $json_obj)))
			{
				$this->errors[] = "Missing 'downloads' section in publish.json";
			}
			if(!(array_key_exists("tools", $json_obj)))
			{
				$this->errors[] = "Missing 'tools' section in publish.json";
			}
			if(!(array_key_exists("files", $json_obj)))
			{
				$this->errors[] = "Missing 'files' section in publish.json";
			}
			if(!(array_key_exists("commands", $json_obj)))
			{
				$this->errors[] = "Missing 'commands' section in publish.json";
			}
		}
		
		$errors = count($this->errors);
		if($errors > 0)
		{
			return $errors; // May as well quit here, we can't continue if we have errors.
		}
		
		// Check that all the necessary files exist
		$parse = explode("/", $dataset_cfg);
		$parse[(count($parse) - 1)] = "";
		$dataset_path = rtrim(implode("/", $parse), "/");
		$files_list = $json_obj['files'];
		@chdir($dataset_path);
		foreach($files_list as $file_req)
		{
			if(!(file_exists($file_req)))
			{
				$this->errors[] = "Missing file '" . $file_req . "', defined in publish.json";
			}
		}
		
		// Check that the dataset actually has an import instruction
		$properties_list = $json_obj['properties'];
		if(!(array_key_exists("import_file", $properties_list)))
		{
			$this->errors[] = "Missing import instruction in publish.json";
		}

		$errors = count($this->errors);
		if($errors == 0)
		{
			$this->config = $json_obj;
		}
		return($errors);
	}
	
	public function prepare($quiet = false, $tools_path = "/usr/bin")
	{
		// Copy quill directory to the hopper
		$this->dupdir($this->quill_path, $this->hopper_path);
		if(!(is_dir($this->hopper_path)))
		{
			$this->errors[] = "Could not create hopper directory " . $this->hopper_path;
			$errors = count($this->errors);
			return($errors);
		}
		
		// Download necessary files
		chdir($this->hopper_path);
		$downloads = $this->config['downloads'];
		foreach($downloads as $download)
		{
			if((array_key_exists("localfile", $download)) & (array_key_exists("download", $download)))
			{
				$this->wget($download['download'], $download['localfile']);
				if(!(file_exists($download['localfile'])))
				{
					$this->errors[] = "Could not download " . $download['download'];
				}
			}
		}
		$errors = count($this->errors);
		if($errors > 0)
		{
			return($errors);
		}
		
		// Install necessary tools
		chdir($this->hopper_path);
		$tools = $this->config['tools'];
		$path = explode(":", $_SERVER['PATH']);
		foreach($tools as $tool)
		{
			$toolpath = $tools_path . "/" . $tool;
			if(!(file_exists($toolpath)))
			{
				foreach($path as $dir)
				{
					$toolpath = $dir . "/" . $tool;
					if(file_exists($toolpath))
					{
						break;
					}
				}
			}
			if(!(file_exists($toolpath)))
			{
				$this->errors[] = "Could not locate tool " . $tool;
				$errors = count($this->errors);
				return($errors);
			}
			$file_perms = fileperms($toolpath);
			copy($toolpath, $this->hopper_path . "/" . $tool);
			chmod($this->hopper_path . "/" . $tool, $file_perms);
			if(!(file_exists($this->hopper_path . "/" . $tool)))
			{
				$this->errors[] = "Could not copy tool " . $tool;
				$errors = count($this->errors);
				return($errors);
			}
		}
		
		// Run prepare scripts
		chdir($this->hopper_path);
		$commands = $this->config['commands'];
		if(array_key_exists("prepare", $commands))
		{
			foreach($commands['prepare'] as $command)
			{
				$file_output = $this->externalScript($command);
				if($file_output['code'] != 0)
				{
					$this->errors[] = "Attempt to run command failed: " . $command . "\n" . $file_output['stderr'];
					$errors = count($this->errors);
					return($errors);
				}
				if((!($quiet)) & (strlen($file_output['stdout']) > 0))
				{
					print("    " . str_replace("\n", "\n    ", $file_output['stdout']) . "\n");
				}
			}
		}
		
		// Check all necessary files exist
		chdir($this->hopper_path);
		$files = $this->config['files'];
		foreach($files as $file)
		{
			if(!(file_exists($file)))
			{
				$this->errors[] = "Could not find required file '" . $file . "'";
			}
		}

		$this->hash_checked = false;
		
		// Count errors and exit
		$errors = count($this->errors);
		return($errors);
	}
	
	public function publish($dumppath, $remotepath, $quiet = false)
	{
		// Set up some variables to start.
		if(array_key_exists("min_triples", $this->config['properties']))
		{
			$min_triples = $this->config['properties']['min_triples'];
		}
		else
		{
			$min_triples = 0;
		}
		if(array_key_exists("warn_triples", $this->config['properties']))
		{
			$warn_triples = $this->config['properties']['warn_triples'];
		}
		else
		{
			$warn_triples = 0;
		}
	
		// First run the 'publish' scripts, if any.
		chdir($this->hopper_path);
		$commands = $this->config['commands'];
		if(array_key_exists("import", $commands))
		{
			foreach($commands['import'] as $command)
			{
				$file_output = $this->externalScript($command);
				if($file_output['code'] != 0)
				{
					$this->errors[] = "Attempt to run command failed: " . $command . "\n" . $file_output['stderr'];
					$errors = count($this->errors);
					return($errors);
				}
				if((!($quiet)) & (strlen($file_output['stdout']) > 0))
				{
					print("    " . str_replace("\n", "\n    ", $file_output['stdout']) . "\n");
				}
			}
		}
		
		// Check for presence of import file
		chdir($this->hopper_path);
		$import_file = $this->config['properties']['import_file'];
		if(!(file_exists($import_file)))
		{
			$this->errors[] = "Import file '" . $import_file . "' not found.";
			$errors = count($this->errors);
			return($errors);
		}

		// Find the path to Rapper, if it exists
		chdir($this->hopper_path);
		$path = explode(":", $_SERVER['PATH']);
		$rapper = "";
		foreach($path as $dir)
		{
			$testpath = rtrim($dir, "/") . "/rapper";
			if(file_exists($testpath))
			{
				$rapper = $testpath;
				break;
			}
		}
		if(strlen($rapper) == 0)
		{
			$this->errors[] = "Cannot find Rapper in the path.";
			$errors = count($this->errors);
			return($errors);
		}
		
		// Generate triples
		chdir($this->hopper_path);
		$cmd_line = $rapper . " -g -o ntriples " . $import_file . " > " . $this->triples_file;
		$triplecount = 0;
		$ret_val = $this->externalScript($cmd_line);
		// Get the number of triples - bit hacky but does the job until I can think of something better.
		// We could count the lines in the ntriples file, but that would take far too much time with massive datasets.
		$m = array();
		if(preg_match("/returned ([0-9]+) triples/", $ret_val['stderr'], $m) > 0)
		{
			$triplecount = (int) $m[1];
		}
		// Now use the same method to get the name of the parser used.
		$m = array();
		$ntriples_file_format = "";
		if(preg_match("/parser name \'([a-zA-Z0-9]+)\'/", $ret_val['stderr'], $m) > 0)
		{
			$ntriples_file_format = strtolower($m[1]);
		}
		
		// If not enough triples were generated, something is wrong and we need to stop here.
		if($triplecount <= $min_triples)
		{
			$this->errors[] = "Error generating triples.\n" . $ret_val['stderr'];
			$errors = count($this->errors);
			return($errors);
		}
		if($triplecount <= $warn_triples)
		{
			display_error("WARNING: Only " . $triplecount . " triples generated!");
		}
		
		// Delete '.private' files
		chdir($this->hopper_path);
		$files = glob('./*.private');
		foreach($files as $file){ 
			if(is_file($file))
			{
				unlink($file);
			}
		}
		
		// Add metadata
		foreach($this->dumpfiles as $dumpfile)
		{
			$uri = $dumpfile['uri'];
			if(strlen($uri) == 0)
			{
				continue;
			}
			$ttl = $this->dumpFileMetadata($uri);
			$fp = fopen($this->triples_file, "a");
			foreach($ttl as $triple)
			{
				fwrite($fp, $triple . "\n");
			}
			fclose($fp);
		}
		
		// Perform dumps

		foreach($this->dumpfiles as $dumpfile)
		{
			$localfile = $dumpfile['filename'];
			$format = $dumpfile['format'];
			$triples_filename = preg_replace("|^(.*)/([^/]+)$|", "$2", $this->triples_file);
			$rdffile = $this->hopper_path . "/" . $localfile;
			$cmd_line = $rapper . " -i ntriples -o " . $format . " " . $this->triples_file . " | sed s#\\<file\\:[^\\>]*" . $triples_filename . "\\>#\\<\\># | sed s#\\<file\\:[^\\>]*" . $localfile . "\\>#\\<\\># > " . $rdffile;
			$ret_val = $this->externalScript($cmd_line);
			if(!(file_exists($rdffile)))
			{
				$this->errors[] = "Error creating dump file " . $rdffile;
				$errors = count($this->errors);
				return($errors);
			}
		}
		
		// Copy contents of the hopper to the dumps path
		$this->ensureDirExists($dumppath);
		$this->deltree($dumppath);
		if(!($this->ensureDirExists($dumppath)))
		{
			$this->errors[] = "Error creating/clearing directory " . $dumppath . " - check file permissions.";
			$errors = count($this->errors);
			return($errors);
		}
		$this->dupdir($this->hopper_path, $dumppath);
		
		// Perform completion scripts, if requested.
		chdir($this->hopper_path);
		$commands = $this->config['commands'];
		if(array_key_exists("completed", $commands))
		{
			foreach($commands['completed'] as $command)
			{
				$file_output = $this->externalScript($command);
				if($file_output['code'] != 0)
				{
					$this->errors[] = "Attempt to run command failed: " . $command . "\n" . $file_output['stderr'];
					$errors = count($this->errors);
					return($errors);
				}
				if((!($quiet)) & (strlen($file_output['stdout']) > 0))
				{
					print("    " . str_replace("\n", "\n    ", $file_output['stdout']) . "\n");
				}
			}
		}
		
		return(0);
	}

	public function dumpFileMetadata($uri)
	{
		$cfg_properties = $this->config['properties'];
		$ttl = array();
		if(array_key_exists('title', $cfg_properties))
		{
			$ttl[] = "<" . $uri . "> <http://purl.org/dc/terms/title> \"" . str_replace("\"", "\\\"", $cfg_properties['title']) . "\" .";
		}
		if(array_key_exists('description', $cfg_properties))
		{
			$ttl[] = "<" . $uri . "> <http://purl.org/dc/terms/description> \"" . str_replace("\"", "\\\"", $cfg_properties['description']) . "\" .";
		}
		if(array_key_exists('stars', $cfg_properties))
		{
			$ttl[] = "<" . $uri . "> <http://purl.org/dc/terms/conformsTo> <http://purl.org/openorg/opendata-" . $cfg_properties['stars'] . "-star> .";
		}
		if(array_key_exists('license', $cfg_properties))
		{
			$licenses = $cfg_properties['license'];
			if(is_array($licenses))
			{
				foreach($licenses as $license)
				{
					$ttl[] = "<" . $uri . "> <http://purl.org/dc/terms/license> <" . $license . "> .";
				}
			}
		}
		if(array_key_exists('publisheruri', $cfg_properties))
		{
			$ttl[] = "<" . $uri . "> <http://purl.org/dc/terms/publisher> <" . $cfg_properties['publisheruri'] . "> .";
			if(array_key_exists('publishername', $cfg_properties))
			{
				$ttl[] = "<" . $cfg_properties['publisheruri'] . "> <http://www.w3.org/2000/01/rdf-schema#label> \"" . str_replace("\"", "\\\"", $cfg_properties['publishername']) . "\" .";
			}

		}
		if(array_key_exists('corrections', $cfg_properties))
		{
			if(preg_match("/.*@.*/", $cfg_properties['corrections']) > 0)
			{
				$ttl[] = "<" . $uri . "> <http://purl.org/openorg/corrections> <mailto:" . $cfg_properties['corrections'] . "> .";
			}
			else
			{
				$ttl[] = "<" . $uri . "> <http://purl.org/openorg/corrections> <" . $cfg_properties['corrections'] . "> .";
			}
		}
		if(array_key_exists('endpoint', $cfg_properties))
		{
			$endpoints = $cfg_properties['endpoint'];
			if(is_array($endpoints))
			{
				foreach($endpoints as $endpoint)
				{
					$ttl[] = "<" . $uri . "> <http://rdfs.org/ns/void#sparqlEndpoint> <" . $endpoint . "> .";
				}
			}
		}
		if(array_key_exists('authority', $cfg_properties))
		{
			if($cfg_properties['authority'])
			{
				$ttl[] = "<" . $uri . "> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/openorg/AuthoritativeDataset> .";
			}
			else
			{
				$ttl[] = "<" . $uri . "> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/openorg/NonAuthoritativeDataset> .";
			}
		}
		return($ttl);
	}

	public function requestRdfDump($filename, $uri="", $format="turtle")
	{
		$item = array();
		$item['filename'] = $filename;
		$item['uri'] = $uri;
		$item['format'] = $format;
		$this->dumpfiles[] = $item;
	}

	// The following three functions handle hash checks. The hashCheck function isn't
	// public because it has side effects, so it may return different results if
	// called twice during the same process, which we don't really want. The
	// changedFiles function remedies this by caching the value returned by
	// hashCheck so it's only called once.

	public function changedFiles($hash_file)
	{
		$check = false;
		@$check = $this->config['properties']['check_hashes'];
		if(!($check))
		{
			return true;
		}
		if(!($this->hash_checked))
		{
			$this->hash_check_result = $this->hashCheck($hash_file);
			$this->hash_checked = true;
		}
		return($this->hash_check_result);
	}
	
	private function writeHashFile($hash_file)
	{
		if(!($handle = opendir($this->hopper_path)))
		{
			return false;
		}
		$fp = fopen($hash_file, "w");
		while (false !== ($entry = readdir($handle)))
		{
			if(is_dir(rtrim($this->hopper_path, "/") . "/" . $entry))
			{
				continue;
			}
			$new_hash = md5_file(rtrim($this->hopper_path, "/") . "/" . $entry);
			fwrite($fp, $new_hash . " " . $entry . "\n");
		}
		fclose($fp);
	}
	
	private function hashCheck($hash_file)
	{
		// Load previous hashes
		$old_hashes = array();
		if(!(file_exists($hash_file)))
		{
			// Hash file doesn't exist, this must be the first publish.
			$this->writeHashFile($hash_file);
			return true;
		}
		$f = file($hash_file);
		foreach($f as $l)
		{
				if(strlen($l) > 0)
				{
						$a = explode(" ", $l, 2);
						$k = trim($a[1]);
						$v = trim($a[0]);
						$old_hashes[$k] = $v;
				}
		}
		$handle = opendir($this->hopper_path);
		while (false !== ($entry = readdir($handle)))
		{
			if(is_dir(rtrim($this->hopper_path, "/") . "/" . $entry))
			{
				continue;
			}
			if(!(array_key_exists($entry, $old_hashes)))
			{
				// New file found, return true.
				$this->writeHashFile($hash_file);
				return true;
			}
			$hash = md5_file(rtrim($this->hopper_path, "/") . "/" . $entry);
			if(strcmp($hash, $old_hashes[$entry]) != 0)
			{
				// File changed, return true.
				$this->writeHashFile($hash_file);
				return true;
			}
		}
		
		return false;
	}

	public function triples()
	{
		if(strlen($this->triples_file) == 0)
		{
			return array();
		}
		if(!(file_exists($this->triples_file)))
		{
			return array();
		}
		return(file($this->triples_file));
	}

	function __construct($cfg_file, $tmp_dir="/tmp")
	{
		$this->creation_time = time();
		$this->extra_triples = array();
		$this->dumpfiles = array();
		$this->quill_path = preg_replace("|/[^/]*$|", "", $cfg_file);
		$this->errors = array();
		$this->hash_checked = false;
		$this->hash_check_result = false;
		if(($this->loadSettingsFile($cfg_file)) > 0)
		{
			throw new Exception(implode(", ", $this->errors));
		}

		$uid = getmypid();
		$parse = explode("/", $cfg_file);
		$c = count($parse);
		$dataset = "data";
		if((strcmp($parse[($c - 1)], "publish.json") == 0) & ($c >= 2))
		{
			$dataset = $parse[($c - 2)];
		}
		$this->hopper_path = rtrim($tmp_dir, "/") . "/" . $dataset . ".new." . $uid;
		$this->triples_file = rtrim($tmp_dir, "/") . "/" . $dataset . "-full.nt." . $uid;
		if(!($this->ensureDirExists($this->hopper_path))) {
			throw new Exception("Cannot create temporary directory for processing");
		}
	}
	
	function __destruct()
	{
		// Perform clear up - remove temporary files.
		$this->deltree($this->hopper_path);
		if(file_exists($this->triples_file))
		{
			unlink($this->triples_file);
		}
	}
}

class HedgehogConfig extends ArrayObject
{
	private $global_settings;

	/* The constructor loads all the values into memory. If called with an argument,
	   the argument is the path name of the settings files. Otherwise it checks the
	   environment variable 'HEDGEHOG_CONFIG', then the path '../settings' relative
	   to the running script. If no settings directory can be found, the object is
	   still created but contains no data.
	*/
	function __construct($settings_path="")
	{
		if(strlen($settings_path) == 0)
		{
			@$settings_path = $_SERVER['HEDGEHOG_CONFIG'];
		}
		if(strlen($settings_path) == 0)
		{
			$parse = explode("/", rtrim(__FILE__, "/"));
			$c = count($parse);
			if($c > 2)
			{
				$parse[($c - 1)] = "";
				$parse[($c - 2)] = "settings";
				$settings_path = rtrim(implode("/", $parse), "/");
			}
		}		
		$r = array();
		if(is_dir($settings_path))
		{
			if($handle = opendir($settings_path))
			{
				while (false !== ($entry = readdir($handle)))
				{
					$full_path = $settings_path . "/" . $entry;
					if(is_dir($full_path))
					{
						continue;
					}
					$lines = file($full_path);
					foreach($lines as $line)
					{
						$settingline = trim($line);
						if(strlen($settingline) <= 0)
						{
							continue;
						}
						if(strcmp(substr($settingline, 0, 1), "#") != 0)
						{
							$settingarray = explode(" ", $settingline, 2);
							if(count($settingarray) == 2)
							{
								$k = $settingarray[0];
								$r[$k] = $settingarray[1];
							}
						}
						
					}
				}
				closedir($handle);
			}		
		}
		$this->global_settings = $r;
	}
	
	function __get($key)
	{
		if(array_key_exists($key, $this->global_settings))
		{
			return($this->global_settings[$key]);
		}
		else
		{
			return("");
		}
	}
	
	function __set($key, $value)
	{
		$this->global_settings[$key] = $value;
	}
	
	public function __isset($name)
	{
		return true;
	}
}

// Command line handling functions

function getDatasets()
{
	global $argv;

	$datasets = array();
	for($i = 1; $i < (count($argv)); $i++)
	{
		if (strcmp(substr($argv[$i], 0, 1), "-") != 0)
		{
			$datasets[] = trim($argv[$i], "/");
		}
	}
	
	return($datasets);
}

function createSwitches()
{
	global $argv;

	$switches = array();

	// Process command line arguments
	$datasets = array();
	$switches = array();
	for($i = 1; $i < (count($argv)); $i++)
	{
		if (strcmp(substr($argv[$i], 0, 1), "-") == 0)
		{
			$k = $argv[$i];
			$switches[$k] = '';
		}
	}
	
	// Set variable $quiet if the user requests it.
	if((array_key_exists("--quiet", $switches)) | (array_key_exists("-quiet", $switches)) | (array_key_exists("-q", $switches)))
	{
		$switches['quiet'] = true;
	}
	else
	{
		$switches['quiet'] = false;
	}
	
	// Set variable $force_import if the user requests it.
	if(array_key_exists("--force", $switches))
	{
		$switches['force'] = true;
	}
	else
	{
		$switches['force'] = false;
	}
	
	// Display help if the user requests it.
	if((array_key_exists("--help", $switches)) | (array_key_exists("-help", $switches)) | (array_key_exists("-h", $switches)) | (array_key_exists("-?", $switches)))
	{
		$switches['help'] = true;
	}
	else 
	{
		$switches['help'] = false;
	}

	return($switches);
}

// Function for displaying command line help.
function display_help($extended=false)
{
	print("publish_dataset\n");
	print("---------------\n");
	print("A tool for publishing datasets within the Hedgehog system.\n\n");
	print("Usage: publish_dataset (options) dataset [dataset [dataset [...]]]\n\n");
	if($extended)
	{
		// Show extended help
		print("Options\n");
		print("  --help   Show this help screen\n");
		print("  --quiet  No output (good for cron)\n");
		print("  --force  Publish even if nothing has changed\n");
	} else {
		print("Use --help switch for more options.\n");
	}
	print("\n");
}

function display_error($text)
{
	// Handy function, prints to STDERR rather than STDOUT
	file_put_contents('php://stderr', $text . "\n");
}

class FourStore
{
	private $url;
	private $max_triples;

	private function replace_chunk($graph, $triples)
	{
		$url = $this->url;
		$data = implode("\n", $triples);
		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $url . $graph);
		curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/x-turtle','Content-Length: ' . strlen($data)));
		curl_setopt($ch, CURLOPT_VERBOSE, 0);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "PUT"); 
		curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
		$r = trim(curl_exec($ch));
		//$err = curl_errno($ch);
		//$cherrmsg = curl_error($ch);
		curl_close($ch);
		
		return($r);
	}
	
	private function append_chunk($graph, $triples)
	{
		$url = $this->url;
		$data = implode("\n", $triples);
		$postdata = array('graph' => $graph, 'data' => $data, 'mime-type' => 'application/x-turtle');
		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $url);
		curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/x-www-form-urlencoded'));
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($ch, CURLOPT_POST, true);
		curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($postdata));
		$r = trim(curl_exec($ch));
		curl_close($ch);	
		
		return($r);
	}
	
	public function replace($graph, $triples)
	{
		$r = array();
		$c = count($triples);
		if($c <= $this->max_triples)
		{
			$r[] = $this->replace_chunk($graph, $triples);
			return($r);
		}
		$i = $this->max_triples;
		$chunk = array_slice($triples, 0, $this->max_triples);
		$r[] = $this->replace_chunk($graph, $chunk);
		while($i < $c)
		{
			$chunk = array_slice($triples, $i, $this->max_triples);
			$r[] = $this->append_chunk($graph, $chunk);
			$i = $i + $this->max_triples;
		}
		return($r);
	}
	
	function __construct($url, $max_triples=10000)
	{
		$this->url = $url;
		$this->max_triples = $max_triples;
	}
}

class Hedgehog
{
	private $config;
	private $quiet;
	private $force;

	public function publishDataset($dataset)
	{
		$quills = $this->config->quills_dir;
		$tmp = $this->config->tmp_dir;
		$dumpdate = date("Y-m-d");

		$cfg = rtrim($quills, "/") . "/" . $dataset . "/publish.json";
		if(!(file_exists($cfg)))
		{
			return("Cannot open quill '" . $dataset . "': config not found.");
		}
		try
		{
			if(is_dir($tmp))
			{
				$quill = new Quill($cfg, $tmp);
			}
			else
			{
				$quill = new Quill($cfg);
			}
		}
		catch (Exception $e)
		{
			return("Cannot open quill '" . $dataset . "': " . $e->getMessage());
		}
		$dump = rtrim($this->config->dumps_dir, "/") . "/" . $dataset . "/" . $dumpdate;
		if(!($this->quiet))
		{
			print("Processing quill '" . $dataset . "'\n");
		}
		if(!($this->quiet))
		{
			print("  Preparing data for publish\n");
		}
		$errors = $quill->prepare($this->quiet, $this->config->tools_dir);
		if($errors > 0)
		{
			return(implode("\n", $quill->errors));
		}
		
		$hash_file = rtrim($this->config->hashes_dir, "/") . "/" . $dataset . ".hash";
		$changed = $quill->changedFiles($hash_file);
		if((!($changed)) & (!($this->force)))
		{
			if(!($this->quiet))
			{
				print("  No modifications, publish aborted\n");
			}
			return "";
		}
		
		// Dump files
		$dump_base = $this->config->target_base_url;
		if(strlen($dump_base) > 0)
		{
			$xmluri = $dump_base . "/" . $dataset . "/" . $dumpdate . "/" . $dataset . ".rdf";
			//$xmluri = "";
			$ttluri = $dump_base . "/" . $dataset . "/" . $dumpdate . "/" . $dataset . ".ttl";
		}
		else
		{
			$xmluri = "";
			$ttluri = "";
		}
		$quill->requestRdfDump($dataset . ".rdf", $xmluri, "rdfxml");
		$quill->requestRdfDump($dataset . ".ttl", $ttluri, "turtle");
		
		if(!($this->quiet))
		{
			print("  Publishing data to " . $dump . "\n");
		}
		$errors = $quill->publish($dump, $this->quiet);
		if($errors > 0)
		{
			return(implode("\n", $quill->errors));
		}
		$graph = $this->config->xml_base . "/dataset/" . $dataset . "/latest";
		if(!($this->quiet))
		{
			print("  Importing into triplestore: " . $graph . "\n");
		}
		$triplestore_url = "";
		@$triplestore_url = $this->config->import_url;
		if(strlen($triplestore_url) > 0)
		{
			$fs = new FourStore($triplestore_url);
			$err = $fs->replace($graph, $quill->triples());
		}
		if(!($this->quiet))
		{
			print("  Publish successful\n");
		}

		return "";
	}
	
	function __construct($quiet=false, $force=false)
	{
		$this->quiet = $quiet;
		$this->force = $force;
		$this->config = new HedgehogConfig();
	}
	
}

// ================== Main script start here =================================

$switches = createSwitches();
$datasets = getDatasets();

// Display help page if requested, or if parameters are incorrect.
if(($switches['help']) | (count($datasets) == 0))
{
	if($switches['help'])
	{
		display_help(true);
	} else {
		display_help();
	}
	exit();
}

$hedgehog = new Hedgehog($switches['quiet'], $switches['force']);

foreach($datasets as $dataset)
{
	$error = $hedgehog->publishDataset($dataset);
	if(strlen($error) > 0)
	{
		display_error($error);
		display_error("Dataset '" . $dataset . "' NOT published.");
	}
}

?>
